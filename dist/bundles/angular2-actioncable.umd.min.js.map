{"version":3,"sources":["ng://angular2-actioncable/src/cable.ts","ng://angular2-actioncable/src/action-cable.service.ts"],"names":["ActionCable","ActionCableNs","Cable","url","params","_this","this","disconnectedSource","Subject","baseCable","createConsumer","buildUrl","Function","disconnected","subscribe","createWebSocketURL","prototype","channel","name","Channel","data","next","asObservable","pipe","debounceTime","disconnect","Object","keys","map","key","encodeURIComponent","join","cable","initializedSource","connectedSource","rejectedSource","eventTypes","channelParams","assign","messages","Observable","observer","mixin","received","forEach","type","baseChannel","subscriptions","create","unsubscribe","initialized","connected","rejected","send","perform","action","complete","ActionCableService","cables","hasOwnProperty","__decorate","Injectable"],"mappings":"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","sourcesContent":["import * as ActionCableNs from '@rails/actioncable';\nimport { Observable, Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\nconst ActionCable = ActionCableNs;\n\nexport class Cable {\n  baseCable: any;\n  private disconnectedSource: Subject<any> = new Subject();\n\n  constructor(public url: string, public params?: any) {\n    this.baseCable = ActionCable.createConsumer(this.buildUrl(url, params));\n\n    // If a function is passed as params, re-evaluate it before attempting to reconnect\n    if (params instanceof Function) {\n      this.disconnected().subscribe(() => {\n        this.baseCable.url = ActionCable.createWebSocketURL(this.buildUrl(url, params));\n      });\n    }\n  }\n\n  /**\n   * Create a new subscription to a channel, optionally with topic parameters.\n   */\n  channel(name: string, params = {}): Channel {\n    const channel = new Channel(this, name, params);\n    channel.disconnected().subscribe(data => this.disconnectedSource.next(data));\n    return channel;\n  }\n\n  /**\n   * Emits when the WebSocket connection is closed.\n   */\n  disconnected(): Observable<any> {\n    return this.disconnectedSource.asObservable().pipe(debounceTime(100));\n  }\n\n  /**\n   * Close the connection.\n   */\n  disconnect(): void {\n    this.baseCable.disconnect();\n  }\n\n  protected buildUrl(url: string, params?: any): string {\n    if (params instanceof Function) {\n      params = params();\n    }\n\n    if (!params) {\n      return url;\n    }\n\n    const paramString = Object.keys(params)\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)\n      .join('&');\n\n    return [url, paramString].join('?');\n  }\n}\n\nexport class Channel {\n  baseChannel: any;\n  messages: Observable<any>;\n  private initializedSource: Subject<any> = new Subject();\n  private connectedSource: Subject<any> = new Subject();\n  private disconnectedSource: Subject<any> = new Subject();\n  private rejectedSource: Subject<any> = new Subject();\n  private eventTypes = ['initialized', 'connected', 'disconnected', 'rejected'];\n\n  constructor(public cable: Cable, public name: string, public params = {}) {\n    const channelParams = Object.assign({}, params, { channel: name });\n    this.messages = new Observable((observer) => {\n      const mixin = {\n        received: (data: any) => observer.next(data),\n      };\n\n      this.eventTypes.forEach((type) => {\n        mixin[type] = (data: any) => this[`${type}Source`].next(data);\n      });\n\n      this.baseChannel = this.cable.baseCable.subscriptions.create(channelParams, mixin);\n      return () => this.unsubscribe();\n    });\n  }\n\n  /**\n   * Emits messages that have been broadcast to the channel.\n   * For easy clean-up, when this Observable is completed the ActionCable channel will also be closed.\n   */\n  received(): Observable<any> {\n    return this.messages;\n  }\n\n  /**\n   * Emits when the subscription is initialized.\n   */\n  initialized(): Observable<any> {\n    return this.initializedSource.asObservable();\n  }\n\n  /**\n   * Emits when the subscription is ready for use on the server.\n   */\n  connected(): Observable<any> {\n    return this.connectedSource.asObservable();\n  }\n\n  /**\n   * Emits when the WebSocket connection is closed.\n   */\n  disconnected(): Observable<any> {\n    return this.disconnectedSource.asObservable();\n  }\n\n  /**\n   * Emits when the subscription is rejected by the server.\n   */\n  rejected(): Observable<any> {\n    return this.rejectedSource.asObservable();\n  }\n\n  /**\n   * Broadcast message to other clients subscribed to this channel.\n   */\n  send(data: any): void {\n    this.baseChannel.send(data);\n  }\n\n  /**\n   * Perform a channel action with the optional data passed as an attribute.\n   */\n  perform(action: string, data?: any): void {\n    this.baseChannel.perform(action, data);\n  }\n\n  /**\n   * Unsubscribe from the channel.\n   */\n  unsubscribe(): void {\n    this.baseChannel.unsubscribe();\n    this.eventTypes.forEach(type => this[`${type}Source`].complete());\n  }\n}\n","import { Injectable } from '@angular/core'\nimport { Cable } from './cable';\n\n@Injectable()\nexport class ActionCableService {\n  private cables: {[s: string]: Cable} = {};\n\n  /**\n   * Open a new ActionCable connection to the url. Any number of connections can be created.\n   */\n  cable(url: string, params?: any): Cable {\n    if (!this.cables.hasOwnProperty(url)) {\n      this.cables[url] = new Cable(url, params);\n    }\n\n    return this.cables[url];\n  }\n\n  /**\n   * Close an open connection for the url.\n   */\n  disconnect(url: string): void {\n    if (this.cables.hasOwnProperty(url)) {\n      this.cables[url].disconnect();\n      delete this.cables[url];\n    }\n  }\n}\n"]}